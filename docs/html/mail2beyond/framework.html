<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mail2beyond.framework API documentation</title>
<meta name="description" content="Module that contains the core framework for mail2beyond." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mail2beyond.framework</code></h1>
</header>
<section id="section-intro">
<p>Module that contains the core framework for mail2beyond.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Module that contains the core framework for mail2beyond.&#34;&#34;&#34;

import email
import inspect
import ipaddress
import re
import logging
import signal
import ssl

from aiosmtpd.controller import Controller


class Error(BaseException):
    &#34;&#34;&#34;Creates the `Error` object used by mail2beyond.&#34;&#34;&#34;
    def __init__(self, message: str):
        super().__init__(message)


class Email:
    &#34;&#34;&#34;
    Creates an `Email` object that contains a decoded SMTP email along with information about the client and server.

    Attributes:
        server (aiosmtpd.smtp.SMTP): The `SMTP` object that handled the email from `aiosmtpd`.
        session (aiosmtpd.smtp.Session): The `Session` object that contains client-connection info from `aiosmtpd`.
        envelope (aiosmtpd.smtp.Envelope): The `Envelope` object that contains the original email as it was received by
            the server from `aiosmtpd`.
        headers (email.message.Message): The Message object from the &#39;email&#39; Python module that contains the decoded
            SMTP headers.


    &#34;&#34;&#34;

    def __init__(self, server, session, envelope):
        &#34;&#34;&#34;
        Initializes the `Email` object with required attributes using parameters.

        Args:
            server (aiosmtpd.smtp.SMTP): The `SMTP` object that handled the email from `aiosmtpd`.
            session (aiosmtpd.smtp.Session): The `Session` object that contains client-connection info from `aiosmtpd`.
            envelope (aiosmtpd.smtp.Envelope): The `Envelope` object that contains the original email as it was received
                by the server from `aiosmtpd`.
        &#34;&#34;&#34;
        self.server = server
        self.session = session
        self.envelope = envelope
        self.headers = email.message_from_bytes(envelope.content)

    def get_peer_ip(self):
        &#34;&#34;&#34;Gets the IP of the remote peer (client).&#34;&#34;&#34;
        return self.session.peer

    def get_peer_ip_and_port(self):
        &#34;&#34;&#34;Gets the IP and port of the remote peer (client) in IP:PORT format.&#34;&#34;&#34;
        return f&#34;{self.session.peer[0]}:{self.session.peer[1]}&#34;

    def get_server_ip_and_port(self):
        &#34;&#34;&#34;Gets the IP and port of the server that accepted the email in IP:PORT format.&#34;&#34;&#34;
        return f&#34;{self.server.event_handler.address}:{self.server.event_handler.port}&#34;

    # Getters and setters
    @property
    def content(self):
        &#34;&#34;&#34;Gets the decoded content body from the email.&#34;&#34;&#34;
        return self.headers.get_payload(decode=True).decode()


class Listener:
    &#34;&#34;&#34;
    Creates the `Listener` object that accepts SMTP/SMTPS requests and applies logic based on a specified mappings.

    Attributes:
        log (logging.Logger): The Logger object the `Listener` will use to log events that occur while listening.
        controller (aiosmtpd.controller.Controller): The `Controller` from `aiosmtpd` that controls the SMTP server.
    &#34;&#34;&#34;
    # Private attributes are not for public consumption.
    # pylint: disable=too-many-instance-attributes

    # Initialize attributes.
    _address = None
    _port = None
    _mappings = None
    _tls_context = None
    _enable_starttls = None
    _require_starttls = None

    def __init__(self, mappings: list, address: str = &#34;127.0.0.1&#34;, port: int = 62125, **kwargs):
        &#34;&#34;&#34;
        Initializes the `Listener` with the required attributes from arguments.

        Args:
            mappings (list): A list of `mail2beyond.framework.Mapping` objects that this listener check whenever an
                SMTP message is received. At list one item is required and one item must be a Mapping with its `pattern`
                attribute set to `default`.
            address (str): The local address the `Listener` will listen for SMTP requests on.
            port (int): The local TCP port the `Listener` will listen for SMTP requests on.
            **tls_context (ssl.SSLContext): The SSLContext object from the &#39;ssl&#39; library that defines the TLS
                configuration for an SMTPS listener. If `None` is specified, the `Listener` will not use TLS.
            **enable_starttls (bool): Enables or disables allowing advertisement of the STARTTLS option that allows
                clients to automatically upgrade insecure SMTP connections to secure connections. This argument is only
                applicable if you have provided a valid `tls_context`.
            **require_starttls (bool): Enables or disables requiring clients to use the STARTTLS option. If enabled, all
                clients must choose the STARTTLS option or the request will be rejected. This argument is only
                applicable if you have set `enable_starttls` to `True`.
        &#34;&#34;&#34;
        # Setup logging
        self.log = None
        self.setup_logging(kwargs.get(&#34;log_level&#34;, logging.NOTSET))

        # Setup mappings and the SMTP controller
        self.controller = None
        self.mappings = mappings
        self.address = address
        self.port = port
        self.tls_context = kwargs.get(&#34;tls_context&#34;, None)
        self.enable_starttls = kwargs.get(&#34;enable_starttls&#34;, False)
        self.require_starttls = kwargs.get(&#34;require_starttls&#34;, False)
        self.setup_controller()

    def start(self):
        &#34;&#34;&#34;
        Starts the `Listener`. This will run the SMTP server in the background. After calling this method, you will
            need to keep the process alive for the SMTP server to continue receiving SMTP connections. You can call the
        `wait()` method to keep the server running indefinitely, or use a function like time.sleep() to keep the
            SMTP server running for a specified amount of time.
        &#34;&#34;&#34;
        self.controller.start()
        self.log.info(f&#34;mail2beyond started listening on {self.address}:{self.port}&#34;)

    @staticmethod
    def wait():
        &#34;&#34;&#34;
        Allows the `Listener` to wait indefinitely, so it can continually accept incoming SMTP messages. This is
        typically called immediately after the `start()` method.
        &#34;&#34;&#34;
        signal.pause()

    def setup_controller(self):
        &#34;&#34;&#34;
        Sets up the `Controller` object with the current address, port and options. If you have made changes to your
        `Listener` object, you will need to call this method to reconfigure the `Controller`.

        Raises:
            mail2beyond.framework.Error: When an unexpected error occurs when creating controllers.
        &#34;&#34;&#34;
        # Setup SMTPS controller if enabled
        if self.tls_context and not self.enable_starttls:
            self.controller = Controller(self, hostname=self.address, port=self.port, ssl_context=self.tls_context)
        # Setup STARTTLS controller if enabled
        elif self.tls_context and self.enable_starttls:
            self.controller = Controller(
                self,
                hostname=self.address,
                port=self.port,
                tls_context=self.tls_context,
                require_starttls=self.require_starttls
            )
        # Setup SMTP controller if no tls_context was provided
        elif not self.tls_context:
            self.controller = Controller(self, hostname=self.address, port=self.port)
        # Throw an error if we somehow ended up here
        else:
            raise Error(&#34;an unexpected error occurred creating the Listener controller&#34;)

    def setup_logging(self, level: int = logging.NOTSET, handler=None, **kwargs):
        &#34;&#34;&#34;
        Sets up the `log` attribute with a configurable Logger for this `Listener`.

        Args:
            level (int): Sets the logging level the Logger will start logging at. See
                https://docs.python.org/3/library/logging.html#logging-levels
            handler (logging.Handler): Sets the logging handler to use. You can pass in a custom Handler like a
                logging.FileHandler to log to a file. If no handler is specified, the default handler
                logging.StreamHandler is assumed which will only print logs to the console.
            **log_format (str): Sets the format of log messages. See
                https://docs.python.org/3/library/logging.html#logging.Formatter.format
            **log_date_format (str): Sets the format of datetime strings in log messages. See
                https://docs.python.org/3/library/logging.html#logging.Formatter.formatTime
        &#34;&#34;&#34;

        # Reset the existing logger
        del self.log

        # Set formatting
        log_format = kwargs.get(&#34;log_format&#34;, &#34;[%(asctime)s][%(levelname)s]:%(message)s&#34;)
        log_date_format = kwargs.get(&#34;log_date_format&#34;, &#34;%b %d %Y %H:%M:%S&#34;)

        # Set handler
        handler = handler if handler else logging.StreamHandler()
        handler.setLevel(level)
        handler.setFormatter(logging.Formatter(fmt=log_format, datefmt=log_date_format))

        # Set the logger
        self.log = logging.getLogger(__name__)
        self.log.setLevel(level)
        self.log.addHandler(handler)

        # Re-assign assigned mappings to re-populate connector loggers
        if self.mappings:
            self.mappings = self.mappings

        # Log debug notice if debug level set
        if level == logging.DEBUG:
            self.log.warning(&#34;logging at level DEBUG may expose sensitive information in logs&#34;)

    def get_default_mapping(self, mappings: (list, None) = None):
        &#34;&#34;&#34;
        Gets the mapping with the `default` pattern from a list of mappings.

        Args:
            mappings (list, None): The list of Mapping objects to search. If none are provided, the mappings defined
                in the `mappings` attribute value will be assumed.

        Raises:
            mail2beyond.framework.Error: When no Mapping object within the list has its `pattern` set to `default`.
        &#34;&#34;&#34;
        # Variables
        mappings = mappings if mappings else self.mappings

        # Loop through each mapping and find the default.
        for mapping in mappings:
            if mapping.pattern == &#34;default&#34;:
                return mapping

        # Return nothing if no default was found.
        raise Error(&#34;mapping with &#39;default&#39; pattern is required&#34;)

    def get_mapping_matches(self, mail: Email):
        &#34;&#34;&#34;
        Gets the mappings that match a specific `Email` object.

        Args:
            mail (mail2beyond.framework.Email): The `Email` object to check for Mapping matches.

        Returns
            list: a list of Mapping objects that matched this `Email`.
        &#34;&#34;&#34;
        # Initialize the default mapping in case there were no direct matches.
        default_mapping = self.get_default_mapping()
        matched_mappings = []

        # Loop through each mapping to check if the condition matches
        for mapping in self.mappings:
            # Only match default as last resort
            if mapping != default_mapping:
                if mapping.is_match(mail.headers.get(mapping.field, None)):
                    matched_mappings.append(mapping)

        # Return the matched mappings if there were any, otherwise return the default mapping.
        if matched_mappings:
            return matched_mappings

        # Otherwise return default mapping
        return [default_mapping]

    async def handle_DATA(self, server, session, envelope):
        &#34;&#34;&#34;
        Overwrites the `handle_DATA()` method from `aiosmtpd` that defines how received SMTP data is handled. There
        shouldn&#39;t be any need for this method to be called explicitly as it is used exclusively by `aiosmtpd`.

        See Also:
            https://aiosmtpd.readthedocs.io/en/latest/handlers.html#handle_DATA

        Args:
            server (aiosmtpd.smtp.SMTP): The `SMTP` object that handled the email from `aiosmtpd`.
            session (aiosmtpd.smtp.Session): The `Session` object that contains client-connection info from `aiosmtpd`.
            envelope (aiosmtpd.smtp.Envelope): The `Envelope` object that contains the original email as it was received
                by the server from `aiosmtpd`.
        &#34;&#34;&#34;
        # Create an email object with the received session and data
        mail = Email(server, session, envelope)

        # Log this connection
        self.log.info(f&#34;server {mail.get_server_ip_and_port()} connection from peer {mail.get_peer_ip_and_port()}&#34;)

        # Pull the mapping that matches this message and send the chat accordingly.
        mappings = self.get_mapping_matches(mail)

        # Loop through each matched mapping and run it&#39;s connector
        for mapping in mappings:
            self.log.debug(
                f&#34;running connector &#39;{mapping.connector}&#39; because {mapping.field.upper()} &#34;
                f&#34;&#39;{mail.headers.get(mapping.field)}&#39; matched mapping &#39;{mapping.pattern}&#39;&#34;
            )

            # Run the connector with this mapping&#39;s parser
            self.log.debug(f&#34;using parser &#39;{mapping.parser}&#39;&#34;)
            mapping.connector.run(mapping.parser(mail))

        return &#39;250 Message accepted&#39;

    # Getters and setters
    @property
    def address(self):
        &#34;&#34;&#34;The property to get and/or set the  address attribute.&#34;&#34;&#34;
        return self._address

    @address.setter
    def address(self, value: str):
        &#34;&#34;&#34;Sets the address attribute after validating the new value.&#34;&#34;&#34;
        # Require address to be valid IP, or localhost
        if value not in [&#34;localhost&#34;]:
            try:
                ipaddress.ip_address(value)
            except ValueError as exc:
                raise Error(&#34;&#39;address&#39; must be valid IP or localhost&#34;) from exc

        self._address = value

    @property
    def port(self):
        &#34;&#34;&#34;The property to get and/or set the  port attribute.&#34;&#34;&#34;
        return self._port

    @port.setter
    def port(self, value: int):
        &#34;&#34;&#34;Sets the port attribute after validating the new value.&#34;&#34;&#34;
        # Require port to be valid TCP port
        if isinstance(value, int) and 1 &lt;= value &lt;= 65535:
            self._port = value
        else:
            raise Error(&#34;&#39;port&#39; must be valid TCP port&#34;)

    @property
    def mappings(self):
        &#34;&#34;&#34;The property to get and/or set the  mappings attribute.&#34;&#34;&#34;
        return self._mappings

    @mappings.setter
    def mappings(self, value: list):
        &#34;&#34;&#34;Sets the mappings attribute after validating the new value.&#34;&#34;&#34;
        # Require mappings to be list
        if not isinstance(value, list):
            raise TypeError(&#34;&#39;mappings&#39; must be type &#39;list&#39;&#34;)

        # Loop through each requested mapping and it is correct object type and a default object is present
        found_default = False
        for mapping in value:
            # Require mapping to be Mapping object
            if not isinstance(mapping, Mapping):
                raise Error(&#34;each &#39;mappings&#39; item must be &#39;Mapping&#39; object&#34;)

            # Check if this mapping is the default.
            if mapping.pattern == &#34;default&#34;:
                # Ensure we have not already found a default
                if not found_default:
                    found_default = True
                else:
                    raise Error(&#34;multiple &#39;mappings&#39; items assigned pattern &#39;default&#39;&#34;)

            # Assign this listener&#39;s logger to each mapping connector
            mapping.connector.log = self.log

        # Ensure we found a default mapping
        if found_default:
            self._mappings = value

        else:
            raise Error(&#34;missing &#39;mappings&#39; item with pattern &#39;default&#39;&#34;)

    @property
    def tls_context(self):
        &#34;&#34;&#34;The property to get and/or set the  tls_context attribute.&#34;&#34;&#34;
        return self._tls_context

    @tls_context.setter
    def tls_context(self, value: ssl.SSLContext):
        &#34;&#34;&#34;Sets the tls_context attribute after validating the new value.&#34;&#34;&#34;
        # Require tls_context to be SSLContext object or None
        if isinstance(value, ssl.SSLContext) or value is None:
            self._tls_context = value
        else:
            raise Error(&#34;&#39;tls_context&#39; must be type &#39;ssl.SSLContext&#39; or &#39;None&#39;&#34;)

    @property
    def enable_starttls(self):
        &#34;&#34;&#34;The property to get and/or set the  enable_starttls attribute.&#34;&#34;&#34;
        return self._enable_starttls

    @enable_starttls.setter
    def enable_starttls(self, value: bool):
        &#34;&#34;&#34;Sets the enable_starttls attribute after validating the new value.&#34;&#34;&#34;
        # Require enable_starttls to be bool
        if isinstance(value, bool):
            self._enable_starttls = value
        else:
            raise Error(&#34;&#39;enable_starttls&#39; must be type &#39;bool&#39;&#34;)

    @property
    def require_starttls(self):
        &#34;&#34;&#34;The property to get and/or set the  require_starttls attribute.&#34;&#34;&#34;
        return self._enable_starttls

    @require_starttls.setter
    def require_starttls(self, value: bool):
        &#34;&#34;&#34;Sets the require_starttls attribute after validating the new value.&#34;&#34;&#34;
        # Require require_starttls to be bool
        if not isinstance(value, bool):
            raise Error(&#34;&#39;require_starttls&#39; must be type &#39;bool&#39;&#34;)

        # Require &#39;enable_tls&#39; to be True before allowing
        if not self.enable_starttls and value:
            raise Error(&#34;&#39;require_starttls&#39; cannot be &#39;True&#39; while &#39;enable_starttls&#39; is &#39;False&#39;&#34;)

        self._require_starttls = value


class Mapping:
    &#34;&#34;&#34;
    Creates a Mapping object that defines parameters to control the formatting and redirection of received SMTP
    messages. Whenever an SMTP message is received, Mappings are checked by the `Listener` to see if the received SMTP
    message headers match the regex defined in the Mapping object.
    &#34;&#34;&#34;
    # Private attributes are not for public consumption.
    # pylint: disable=too-many-instance-attributes

    # Initialize attributes
    _pattern = None
    _field = None
    _connector = None
    _parser = None

    def __init__(self, pattern: str, connector, **kwargs):
        &#34;&#34;&#34;
        Initializes the Mapping object with desired attributes.

        Args:
            pattern (str): The regex pattern to use when checking SMTP headers for specific values.
            connector (mail2beyond.framework.BaseConnector): The Connector object this Mapping will use whenever a
                match is found. This must be an object of a class that has a base class of
                `mail2beyond.framework.BaseConnector`. You should pass in a built-in `Connector` object created from the
                mail2beyond.connectors module or your own custom `Connector` object.
            **field (str) The SMTP header to run the regex pattern against. This is commonly the TO or FROM headers to
                check the email&#39;s recipient or sender respectively, but can be any header available in the received
                email. Defaults to `from`.
            **parser (mail2beyond.framework.BaseParser): The Parser class to use whenever this Mapping is matched. This
                allows you to specify a Parser class that will parse the email&#39;s content body to a more human-readable
                format. Note this must be the Parser class NOT a `Parser` object. This must be Parser class with a base
                class of `mail2beyond.framework.BaseParser`. Defaults to the `mail2beyond.framework.BaseParser` class,
                but it is strongly recommended you pass in `mail2beyond.parsers.auto.Parser` to automatically parse
                the content body based on the email&#39;s content-type header or pass in your own custom parser class.

        See Also:
            https://github.com/jaredhendrickson13/mail2beyond/blob/master/docs/PACKAGE.md#writing-custom-connectors
            https://github.com/jaredhendrickson13/mail2beyond/blob/master/docs/PACKAGE.md#writing-custom-parsers
        &#34;&#34;&#34;
        # Assign required attributes
        self.pattern = pattern
        self.connector = connector

        # Assign optional attributes, or assume defaults.
        self.field = kwargs.get(&#34;field&#34;, &#34;from&#34;)
        self.parser = kwargs.get(&#34;parser&#34;, BaseParser)

    def __str__(self):
        &#34;&#34;&#34;Sets the object&#39;s pattern as the string representation of this object.&#34;&#34;&#34;
        return self.pattern

    def is_match(self, value):
        &#34;&#34;&#34;
        Checks if a specified value matches this mapping.

        Args:
            value (str): The value to check for a regex pattern match.

        Returns:
            bool: Whether the value was a match for the regex pattern or not.
        &#34;&#34;&#34;
        # Check if the value matches this mapping&#39;s regex pattern.
        if value is not None and re.search(self.pattern, value):
            return True
        # No match, return False
        return False

    # Getters and setters #
    @property
    def pattern(self):
        &#34;&#34;&#34;The property to get and/or set the  pattern attribute.&#34;&#34;&#34;
        return self._pattern

    @pattern.setter
    def pattern(self, value: str):
        &#34;&#34;&#34;Sets the pattern attribute after validating the new value.&#34;&#34;&#34;
        # Require pattern to be a string
        if isinstance(value, str):
            self._pattern = value
        else:
            raise TypeError(&#34;pattern must be type &#39;str&#39;&#34;)

    @property
    def connector(self):
        &#34;&#34;&#34;The property to get and/or set the  connector attribute.&#34;&#34;&#34;
        return self._connector

    @connector.setter
    def connector(self, value):
        &#34;&#34;&#34;Sets the connector attribute after validating the new value.&#34;&#34;&#34;
        # Require connector to have a base class of mail2beyond.framework.BaseConnector
        if value.__class__.__base__ == BaseConnector:
            self._connector = value
        else:
            raise TypeError(&#34;connector must be object with base class &#39;BaseConnector&#39;&#34;)

    @property
    def parser(self):
        &#34;&#34;&#34;The property to get and/or set the  parser attribute.&#34;&#34;&#34;
        return self._parser

    @parser.setter
    def parser(self, value):
        &#34;&#34;&#34;Sets the parser attribute after validating the new value.&#34;&#34;&#34;
        # Require parser to have a base class of mail2beyond.framework.BaseParser
        if inspect.isclass(value) and hasattr(value, &#34;parse_content&#34;):
            self._parser = value
        else:
            raise TypeError(&#34;parser must be a class (not object) with base class &#39;BaseParser&#39;&#34;)

    @property
    def field(self):
        &#34;&#34;&#34;The property to get and/or set the  field attribute.&#34;&#34;&#34;
        return self._field

    @field.setter
    def field(self, value: str):
        &#34;&#34;&#34;Sets the field attribute after validating the new value.&#34;&#34;&#34;
        # Require field to be a support/recognized field
        if isinstance(value, str):
            self._field = value
        else:
            raise ValueError(&#34;field must be type &#39;str&#39;&#34;)


class BaseConnector:
    &#34;&#34;&#34;
    Creates the BaseConnector object to be extended by configurable child classes. This establishes standard
    methods and attributes for creating plugin API connectors.

    Attributes:
        name (str): The name of the created object. This attribute is primarily used for the CLI, but could be useful
            for other reasons.
        log (logging.Logger): The Logger object to use when logging events that occur when the `Connector` is called.
        config (dict): The dict of custom `Connector` configuration values. Any arguments passed in when the object
            is initially created will be populated here. Some Connectors will require configurable values like URLs,
            credentials, etc. This is where those values should be passed in.
    &#34;&#34;&#34;
    # Attributes
    name = &#34;&#34;

    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        Initialize the object with required attributes.

        Notes:
            Any arguments passed in when this object is created will be stored in the &#39;config&#39; attribute of the object.
        &#34;&#34;&#34;
        self.config = kwargs
        self.log = logging.getLogger(__name__)

    def __str__(self):
        &#34;&#34;&#34;Sets this object&#39;s name attribute as its string representation.&#34;&#34;&#34;
        return self.name

    def run(self, parser):
        &#34;&#34;&#34;
        Runs the current connector object. This method calls the `pre_submit()` and `submit()` methods respectively and
        checks for any errors encountered.

        Args:
            parser (mail2beyond.framework.BaseParser): The `Parser` object to use when this `Connector` is called. This
                will the object created by the mapping&#39;s parser and will contain the parsed email content.
                Note this must be the `Parser` object NOT a `Parser` class. This must be `Parser` object with a base
                class of `mail2beyond.framework.BaseParser`.

        Raises:
            mail2beyond.framework.Error: When the `pre_submit()` method catches a `mail2beyond.framework.Error`.
            Exception: When the `submit()` method catches any error, the error will simply be re-raised by this method.
        &#34;&#34;&#34;
        # Try to run pre-submit checks and log errors.
        try:
            self.pre_submit(parser)
        except Error as pre_submit_err:
            self.log.error(f&#34;pre-submit checks for connector &#39;{self}&#39; failed ({pre_submit_err})&#34;)
            raise pre_submit_err

        # Try to run a submit and log errors
        try:
            self.submit(parser)
        except Exception as submit_error:
            self.log.error(f&#34;submit for connector &#39;{self}&#39; failed ({submit_error})&#34;)
            raise submit_error

    def submit(self, parser):
        &#34;&#34;&#34;
        Initializes the `submit()` method that performs actions required for the connector redirect the SMTP message.
        This method is intended to be overwritten by a child class that creates a `Connector` object for a specific API
        or service. If this method is not overwritten by the child class, an error is raised. When overwriting this
        method, you can use the `parser` object to reference various components in the received SMTP message and the
        `config` attribute to reference required configuration values. You can also log events in this method using
        the `log` attribute.

        Args:
            parser (mail2beyond.framework.BaseParser): The `Parser` object to use when this `Connector` is called. This
                will the object created by the mapping&#39;s parser and will contain the parsed email content.
                Note this must be the `Parser` object NOT a `Parser` class. This must be `Parser` object with a base
                class of `mail2beyond.framework.BaseParser`.

        Raises:
            mail2beyond.framework.Error: When the `submit()` method has not been overwritten by a child class.
        &#34;&#34;&#34;
        raise Error(f&#34;method has not been overwritten by child class but received {parser}&#34;)

    def pre_submit(self, parser):
        &#34;&#34;&#34;
        Initializes the `pre_submit()` method that performs validation before the connector&#39;s `submit()` method is
        called.This method is intended to be overwritten by a child class that creates `Connector` objects for a
        specific API. Typically, ths method will be used to validate the contents of the `Connector` object&#39;s `config`
        attribute. But could also be used to validate the parsed email values using the `parser` attribute. When
        overwriting this method, simply raise a `mail2beyond.framework.Error` to mark the `pre_submit()` checks as a
        failure. You can also log events in this method using the `log` attribute.

        Args:
            parser (mail2beyond.framework.BaseParser): The `Parser` object to use when this `Connector` is called. This
                will the object created by the mapping&#39;s parser and will contain the parsed email content.
                Note this must be the `Parser` object NOT a `Parser` class. This must be `Parser` object with a base
                class of `mail2beyond.framework.BaseParser`.

        Returns:
            mail2beyond.framework.BaseParser: Simply returns the `Parser` object by default,
        &#34;&#34;&#34;
        return parser


class BaseParser:
    &#34;&#34;&#34;
    Creates a `BaseParser` object that can be used to further parse an `Email` object&#39;s content body.

    Attributes:
        name (str): The name of the object. This can be used to differentiate different parser objects from each other.
        mail (mail2beyond.framework.Email): The `Email` object containing the decoded email contents.
        log (logging.Logger): The Logger object to use when logging events that occur when the Parser is called.
        config (dict): The dict of custom `Parser` configuration values. Any extra arguments passed in when the object
            is initially created will be populated here. This can be used to define configurable attributes to your
            custom Parser classes.
    &#34;&#34;&#34;
    name = &#34;&#34;
    _mail = None
    _config = None

    def __init__(self, mail: Email, **kwargs):
        &#34;&#34;&#34;
        Initializes the `Parser` object with required attributes.

        Args:
            mail (mail2beyond.framework.Email): The `Email` object containing the decoded email contents.

        Notes:
            Any extra arguments passed in when this object is created will be stored in the &#39;config&#39; attribute of the
                object.
        &#34;&#34;&#34;
        self.mail = mail
        self.config = kwargs
        self.log = logging.getLogger(__name__)

    def __str__(self):
        &#34;&#34;&#34;Sets the string representation of this object.&#34;&#34;&#34;
        return self.name

    def parse_content(self):
        &#34;&#34;&#34;
        Initializes the `Parser` object&#39;s `parse_content()` method. This method is intended to be overwritten by a child
        class to add parsers for various formats.

        Returns:
            str: By default, this method will simply return the current content decoded content from the &#39;mail&#39;
                attribute. This method is intended to be overwritten by a child class to extend functionality.
        &#34;&#34;&#34;
        return self.mail.content

    # Getters and setters
    @property
    def mail(self):
        &#34;&#34;&#34;The property to get and/or set the  mail attribute.&#34;&#34;&#34;
        return self._mail

    @mail.setter
    def mail(self, value: Email):
        &#34;&#34;&#34;Sets the mail attribute after validating the new value.&#34;&#34;&#34;
        # Ensure value is a mail2beyond.framework.Email object
        if not isinstance(value, Email):
            raise Error(&#34;&#39;parser&#39; must be type &#39;mail2beyond.framework.Email&#39;&#34;)

        self._mail = value

    @property
    def subject(self):
        &#34;&#34;&#34;The property to get and/or set the  subject attribute.&#34;&#34;&#34;
        return self.mail.headers.get(&#34;subject&#34;, &#34;No subject&#34;)

    @property
    def content(self):
        &#34;&#34;&#34;Gets the parsed content. This is essentially a shortcut for calling parse_content().&#34;&#34;&#34;
        return self.parse_content()

    @property
    def config(self):
        &#34;&#34;&#34;The property to get and/or set the  config attribute.&#34;&#34;&#34;
        return self._config

    @config.setter
    def config(self, value: dict):
        &#34;&#34;&#34;Sets the config attribute after validating the new value.&#34;&#34;&#34;
        # Ensure config is a dict
        if not isinstance(value, dict):
            raise Error(&#34;&#39;config&#39; must be type &#39;dict&#39;&#34;)

        self._config = value</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mail2beyond.framework.BaseConnector"><code class="flex name class">
<span>class <span class="ident">BaseConnector</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the BaseConnector object to be extended by configurable child classes. This establishes standard
methods and attributes for creating plugin API connectors.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the created object. This attribute is primarily used for the CLI, but could be useful
for other reasons.</dd>
<dt><strong><code>log</code></strong> :&ensp;<code>logging.Logger</code></dt>
<dd>The Logger object to use when logging events that occur when the <code>Connector</code> is called.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>The dict of custom <code>Connector</code> configuration values. Any arguments passed in when the object
is initially created will be populated here. Some Connectors will require configurable values like URLs,
credentials, etc. This is where those values should be passed in.</dd>
</dl>
<p>Initialize the object with required attributes.</p>
<h2 id="notes">Notes</h2>
<p>Any arguments passed in when this object is created will be stored in the 'config' attribute of the object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseConnector:
    &#34;&#34;&#34;
    Creates the BaseConnector object to be extended by configurable child classes. This establishes standard
    methods and attributes for creating plugin API connectors.

    Attributes:
        name (str): The name of the created object. This attribute is primarily used for the CLI, but could be useful
            for other reasons.
        log (logging.Logger): The Logger object to use when logging events that occur when the `Connector` is called.
        config (dict): The dict of custom `Connector` configuration values. Any arguments passed in when the object
            is initially created will be populated here. Some Connectors will require configurable values like URLs,
            credentials, etc. This is where those values should be passed in.
    &#34;&#34;&#34;
    # Attributes
    name = &#34;&#34;

    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        Initialize the object with required attributes.

        Notes:
            Any arguments passed in when this object is created will be stored in the &#39;config&#39; attribute of the object.
        &#34;&#34;&#34;
        self.config = kwargs
        self.log = logging.getLogger(__name__)

    def __str__(self):
        &#34;&#34;&#34;Sets this object&#39;s name attribute as its string representation.&#34;&#34;&#34;
        return self.name

    def run(self, parser):
        &#34;&#34;&#34;
        Runs the current connector object. This method calls the `pre_submit()` and `submit()` methods respectively and
        checks for any errors encountered.

        Args:
            parser (mail2beyond.framework.BaseParser): The `Parser` object to use when this `Connector` is called. This
                will the object created by the mapping&#39;s parser and will contain the parsed email content.
                Note this must be the `Parser` object NOT a `Parser` class. This must be `Parser` object with a base
                class of `mail2beyond.framework.BaseParser`.

        Raises:
            mail2beyond.framework.Error: When the `pre_submit()` method catches a `mail2beyond.framework.Error`.
            Exception: When the `submit()` method catches any error, the error will simply be re-raised by this method.
        &#34;&#34;&#34;
        # Try to run pre-submit checks and log errors.
        try:
            self.pre_submit(parser)
        except Error as pre_submit_err:
            self.log.error(f&#34;pre-submit checks for connector &#39;{self}&#39; failed ({pre_submit_err})&#34;)
            raise pre_submit_err

        # Try to run a submit and log errors
        try:
            self.submit(parser)
        except Exception as submit_error:
            self.log.error(f&#34;submit for connector &#39;{self}&#39; failed ({submit_error})&#34;)
            raise submit_error

    def submit(self, parser):
        &#34;&#34;&#34;
        Initializes the `submit()` method that performs actions required for the connector redirect the SMTP message.
        This method is intended to be overwritten by a child class that creates a `Connector` object for a specific API
        or service. If this method is not overwritten by the child class, an error is raised. When overwriting this
        method, you can use the `parser` object to reference various components in the received SMTP message and the
        `config` attribute to reference required configuration values. You can also log events in this method using
        the `log` attribute.

        Args:
            parser (mail2beyond.framework.BaseParser): The `Parser` object to use when this `Connector` is called. This
                will the object created by the mapping&#39;s parser and will contain the parsed email content.
                Note this must be the `Parser` object NOT a `Parser` class. This must be `Parser` object with a base
                class of `mail2beyond.framework.BaseParser`.

        Raises:
            mail2beyond.framework.Error: When the `submit()` method has not been overwritten by a child class.
        &#34;&#34;&#34;
        raise Error(f&#34;method has not been overwritten by child class but received {parser}&#34;)

    def pre_submit(self, parser):
        &#34;&#34;&#34;
        Initializes the `pre_submit()` method that performs validation before the connector&#39;s `submit()` method is
        called.This method is intended to be overwritten by a child class that creates `Connector` objects for a
        specific API. Typically, ths method will be used to validate the contents of the `Connector` object&#39;s `config`
        attribute. But could also be used to validate the parsed email values using the `parser` attribute. When
        overwriting this method, simply raise a `mail2beyond.framework.Error` to mark the `pre_submit()` checks as a
        failure. You can also log events in this method using the `log` attribute.

        Args:
            parser (mail2beyond.framework.BaseParser): The `Parser` object to use when this `Connector` is called. This
                will the object created by the mapping&#39;s parser and will contain the parsed email content.
                Note this must be the `Parser` object NOT a `Parser` class. This must be `Parser` object with a base
                class of `mail2beyond.framework.BaseParser`.

        Returns:
            mail2beyond.framework.BaseParser: Simply returns the `Parser` object by default,
        &#34;&#34;&#34;
        return parser</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mail2beyond.connectors.google_chat.Connector" href="connectors/google_chat.html#mail2beyond.connectors.google_chat.Connector">Connector</a></li>
<li><a title="mail2beyond.connectors.slack.Connector" href="connectors/slack.html#mail2beyond.connectors.slack.Connector">Connector</a></li>
<li><a title="mail2beyond.connectors.smtp.Connector" href="connectors/smtp.html#mail2beyond.connectors.smtp.Connector">Connector</a></li>
<li><a title="mail2beyond.connectors.void.Connector" href="connectors/void.html#mail2beyond.connectors.void.Connector">Connector</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mail2beyond.framework.BaseConnector.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mail2beyond.framework.BaseConnector.pre_submit"><code class="name flex">
<span>def <span class="ident">pre_submit</span></span>(<span>self, parser)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the <code>pre_submit()</code> method that performs validation before the connector's <code>submit()</code> method is
called.This method is intended to be overwritten by a child class that creates <code>Connector</code> objects for a
specific API. Typically, ths method will be used to validate the contents of the <code>Connector</code> object's <code>config</code>
attribute. But could also be used to validate the parsed email values using the <code>parser</code> attribute. When
overwriting this method, simply raise a <code><a title="mail2beyond.framework.Error" href="#mail2beyond.framework.Error">Error</a></code> to mark the <code>pre_submit()</code> checks as a
failure. You can also log events in this method using the <code>log</code> attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parser</code></strong> :&ensp;<code><a title="mail2beyond.framework.BaseParser" href="#mail2beyond.framework.BaseParser">BaseParser</a></code></dt>
<dd>The <code>Parser</code> object to use when this <code>Connector</code> is called. This
will the object created by the mapping's parser and will contain the parsed email content.
Note this must be the <code>Parser</code> object NOT a <code>Parser</code> class. This must be <code>Parser</code> object with a base
class of <code><a title="mail2beyond.framework.BaseParser" href="#mail2beyond.framework.BaseParser">BaseParser</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="mail2beyond.framework.BaseParser" href="#mail2beyond.framework.BaseParser">BaseParser</a></code></dt>
<dd>Simply returns the <code>Parser</code> object by default,</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pre_submit(self, parser):
    &#34;&#34;&#34;
    Initializes the `pre_submit()` method that performs validation before the connector&#39;s `submit()` method is
    called.This method is intended to be overwritten by a child class that creates `Connector` objects for a
    specific API. Typically, ths method will be used to validate the contents of the `Connector` object&#39;s `config`
    attribute. But could also be used to validate the parsed email values using the `parser` attribute. When
    overwriting this method, simply raise a `mail2beyond.framework.Error` to mark the `pre_submit()` checks as a
    failure. You can also log events in this method using the `log` attribute.

    Args:
        parser (mail2beyond.framework.BaseParser): The `Parser` object to use when this `Connector` is called. This
            will the object created by the mapping&#39;s parser and will contain the parsed email content.
            Note this must be the `Parser` object NOT a `Parser` class. This must be `Parser` object with a base
            class of `mail2beyond.framework.BaseParser`.

    Returns:
        mail2beyond.framework.BaseParser: Simply returns the `Parser` object by default,
    &#34;&#34;&#34;
    return parser</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.BaseConnector.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, parser)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the current connector object. This method calls the <code>pre_submit()</code> and <code>submit()</code> methods respectively and
checks for any errors encountered.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parser</code></strong> :&ensp;<code><a title="mail2beyond.framework.BaseParser" href="#mail2beyond.framework.BaseParser">BaseParser</a></code></dt>
<dd>The <code>Parser</code> object to use when this <code>Connector</code> is called. This
will the object created by the mapping's parser and will contain the parsed email content.
Note this must be the <code>Parser</code> object NOT a <code>Parser</code> class. This must be <code>Parser</code> object with a base
class of <code><a title="mail2beyond.framework.BaseParser" href="#mail2beyond.framework.BaseParser">BaseParser</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="mail2beyond.framework.Error" href="#mail2beyond.framework.Error">Error</a></code></dt>
<dd>When the <code>pre_submit()</code> method catches a <code><a title="mail2beyond.framework.Error" href="#mail2beyond.framework.Error">Error</a></code>.</dd>
<dt><code>Exception</code></dt>
<dd>When the <code>submit()</code> method catches any error, the error will simply be re-raised by this method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, parser):
    &#34;&#34;&#34;
    Runs the current connector object. This method calls the `pre_submit()` and `submit()` methods respectively and
    checks for any errors encountered.

    Args:
        parser (mail2beyond.framework.BaseParser): The `Parser` object to use when this `Connector` is called. This
            will the object created by the mapping&#39;s parser and will contain the parsed email content.
            Note this must be the `Parser` object NOT a `Parser` class. This must be `Parser` object with a base
            class of `mail2beyond.framework.BaseParser`.

    Raises:
        mail2beyond.framework.Error: When the `pre_submit()` method catches a `mail2beyond.framework.Error`.
        Exception: When the `submit()` method catches any error, the error will simply be re-raised by this method.
    &#34;&#34;&#34;
    # Try to run pre-submit checks and log errors.
    try:
        self.pre_submit(parser)
    except Error as pre_submit_err:
        self.log.error(f&#34;pre-submit checks for connector &#39;{self}&#39; failed ({pre_submit_err})&#34;)
        raise pre_submit_err

    # Try to run a submit and log errors
    try:
        self.submit(parser)
    except Exception as submit_error:
        self.log.error(f&#34;submit for connector &#39;{self}&#39; failed ({submit_error})&#34;)
        raise submit_error</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.BaseConnector.submit"><code class="name flex">
<span>def <span class="ident">submit</span></span>(<span>self, parser)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the <code>submit()</code> method that performs actions required for the connector redirect the SMTP message.
This method is intended to be overwritten by a child class that creates a <code>Connector</code> object for a specific API
or service. If this method is not overwritten by the child class, an error is raised. When overwriting this
method, you can use the <code>parser</code> object to reference various components in the received SMTP message and the
<code>config</code> attribute to reference required configuration values. You can also log events in this method using
the <code>log</code> attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parser</code></strong> :&ensp;<code><a title="mail2beyond.framework.BaseParser" href="#mail2beyond.framework.BaseParser">BaseParser</a></code></dt>
<dd>The <code>Parser</code> object to use when this <code>Connector</code> is called. This
will the object created by the mapping's parser and will contain the parsed email content.
Note this must be the <code>Parser</code> object NOT a <code>Parser</code> class. This must be <code>Parser</code> object with a base
class of <code><a title="mail2beyond.framework.BaseParser" href="#mail2beyond.framework.BaseParser">BaseParser</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="mail2beyond.framework.Error" href="#mail2beyond.framework.Error">Error</a></code></dt>
<dd>When the <code>submit()</code> method has not been overwritten by a child class.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit(self, parser):
    &#34;&#34;&#34;
    Initializes the `submit()` method that performs actions required for the connector redirect the SMTP message.
    This method is intended to be overwritten by a child class that creates a `Connector` object for a specific API
    or service. If this method is not overwritten by the child class, an error is raised. When overwriting this
    method, you can use the `parser` object to reference various components in the received SMTP message and the
    `config` attribute to reference required configuration values. You can also log events in this method using
    the `log` attribute.

    Args:
        parser (mail2beyond.framework.BaseParser): The `Parser` object to use when this `Connector` is called. This
            will the object created by the mapping&#39;s parser and will contain the parsed email content.
            Note this must be the `Parser` object NOT a `Parser` class. This must be `Parser` object with a base
            class of `mail2beyond.framework.BaseParser`.

    Raises:
        mail2beyond.framework.Error: When the `submit()` method has not been overwritten by a child class.
    &#34;&#34;&#34;
    raise Error(f&#34;method has not been overwritten by child class but received {parser}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mail2beyond.framework.BaseParser"><code class="flex name class">
<span>class <span class="ident">BaseParser</span></span>
<span>(</span><span>mail:<a title="mail2beyond.framework.Email" href="#mail2beyond.framework.Email">Email</a>, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a <code><a title="mail2beyond.framework.BaseParser" href="#mail2beyond.framework.BaseParser">BaseParser</a></code> object that can be used to further parse an <code><a title="mail2beyond.framework.Email" href="#mail2beyond.framework.Email">Email</a></code> object's content body.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the object. This can be used to differentiate different parser objects from each other.</dd>
<dt><strong><code>mail</code></strong> :&ensp;<code><a title="mail2beyond.framework.Email" href="#mail2beyond.framework.Email">Email</a></code></dt>
<dd>The <code><a title="mail2beyond.framework.Email" href="#mail2beyond.framework.Email">Email</a></code> object containing the decoded email contents.</dd>
<dt><strong><code>log</code></strong> :&ensp;<code>logging.Logger</code></dt>
<dd>The Logger object to use when logging events that occur when the Parser is called.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>The dict of custom <code>Parser</code> configuration values. Any extra arguments passed in when the object
is initially created will be populated here. This can be used to define configurable attributes to your
custom Parser classes.</dd>
</dl>
<p>Initializes the <code>Parser</code> object with required attributes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mail</code></strong> :&ensp;<code><a title="mail2beyond.framework.Email" href="#mail2beyond.framework.Email">Email</a></code></dt>
<dd>The <code><a title="mail2beyond.framework.Email" href="#mail2beyond.framework.Email">Email</a></code> object containing the decoded email contents.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Any extra arguments passed in when this object is created will be stored in the 'config' attribute of the
object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseParser:
    &#34;&#34;&#34;
    Creates a `BaseParser` object that can be used to further parse an `Email` object&#39;s content body.

    Attributes:
        name (str): The name of the object. This can be used to differentiate different parser objects from each other.
        mail (mail2beyond.framework.Email): The `Email` object containing the decoded email contents.
        log (logging.Logger): The Logger object to use when logging events that occur when the Parser is called.
        config (dict): The dict of custom `Parser` configuration values. Any extra arguments passed in when the object
            is initially created will be populated here. This can be used to define configurable attributes to your
            custom Parser classes.
    &#34;&#34;&#34;
    name = &#34;&#34;
    _mail = None
    _config = None

    def __init__(self, mail: Email, **kwargs):
        &#34;&#34;&#34;
        Initializes the `Parser` object with required attributes.

        Args:
            mail (mail2beyond.framework.Email): The `Email` object containing the decoded email contents.

        Notes:
            Any extra arguments passed in when this object is created will be stored in the &#39;config&#39; attribute of the
                object.
        &#34;&#34;&#34;
        self.mail = mail
        self.config = kwargs
        self.log = logging.getLogger(__name__)

    def __str__(self):
        &#34;&#34;&#34;Sets the string representation of this object.&#34;&#34;&#34;
        return self.name

    def parse_content(self):
        &#34;&#34;&#34;
        Initializes the `Parser` object&#39;s `parse_content()` method. This method is intended to be overwritten by a child
        class to add parsers for various formats.

        Returns:
            str: By default, this method will simply return the current content decoded content from the &#39;mail&#39;
                attribute. This method is intended to be overwritten by a child class to extend functionality.
        &#34;&#34;&#34;
        return self.mail.content

    # Getters and setters
    @property
    def mail(self):
        &#34;&#34;&#34;The property to get and/or set the  mail attribute.&#34;&#34;&#34;
        return self._mail

    @mail.setter
    def mail(self, value: Email):
        &#34;&#34;&#34;Sets the mail attribute after validating the new value.&#34;&#34;&#34;
        # Ensure value is a mail2beyond.framework.Email object
        if not isinstance(value, Email):
            raise Error(&#34;&#39;parser&#39; must be type &#39;mail2beyond.framework.Email&#39;&#34;)

        self._mail = value

    @property
    def subject(self):
        &#34;&#34;&#34;The property to get and/or set the  subject attribute.&#34;&#34;&#34;
        return self.mail.headers.get(&#34;subject&#34;, &#34;No subject&#34;)

    @property
    def content(self):
        &#34;&#34;&#34;Gets the parsed content. This is essentially a shortcut for calling parse_content().&#34;&#34;&#34;
        return self.parse_content()

    @property
    def config(self):
        &#34;&#34;&#34;The property to get and/or set the  config attribute.&#34;&#34;&#34;
        return self._config

    @config.setter
    def config(self, value: dict):
        &#34;&#34;&#34;Sets the config attribute after validating the new value.&#34;&#34;&#34;
        # Ensure config is a dict
        if not isinstance(value, dict):
            raise Error(&#34;&#39;config&#39; must be type &#39;dict&#39;&#34;)

        self._config = value</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mail2beyond.parsers.auto.Parser" href="parsers/auto.html#mail2beyond.parsers.auto.Parser">Parser</a></li>
<li><a title="mail2beyond.parsers.html.Parser" href="parsers/html.html#mail2beyond.parsers.html.Parser">Parser</a></li>
<li><a title="mail2beyond.parsers.plain.Parser" href="parsers/plain.html#mail2beyond.parsers.plain.Parser">Parser</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mail2beyond.framework.BaseParser.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="mail2beyond.framework.BaseParser.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<div class="desc"><p>The property to get and/or set the
config attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def config(self):
    &#34;&#34;&#34;The property to get and/or set the  config attribute.&#34;&#34;&#34;
    return self._config</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.BaseParser.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>Gets the parsed content. This is essentially a shortcut for calling parse_content().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def content(self):
    &#34;&#34;&#34;Gets the parsed content. This is essentially a shortcut for calling parse_content().&#34;&#34;&#34;
    return self.parse_content()</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.BaseParser.mail"><code class="name">var <span class="ident">mail</span></code></dt>
<dd>
<div class="desc"><p>The property to get and/or set the
mail attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mail(self):
    &#34;&#34;&#34;The property to get and/or set the  mail attribute.&#34;&#34;&#34;
    return self._mail</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.BaseParser.subject"><code class="name">var <span class="ident">subject</span></code></dt>
<dd>
<div class="desc"><p>The property to get and/or set the
subject attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def subject(self):
    &#34;&#34;&#34;The property to get and/or set the  subject attribute.&#34;&#34;&#34;
    return self.mail.headers.get(&#34;subject&#34;, &#34;No subject&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mail2beyond.framework.BaseParser.parse_content"><code class="name flex">
<span>def <span class="ident">parse_content</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the <code>Parser</code> object's <code>parse_content()</code> method. This method is intended to be overwritten by a child
class to add parsers for various formats.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>By default, this method will simply return the current content decoded content from the 'mail'
attribute. This method is intended to be overwritten by a child class to extend functionality.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_content(self):
    &#34;&#34;&#34;
    Initializes the `Parser` object&#39;s `parse_content()` method. This method is intended to be overwritten by a child
    class to add parsers for various formats.

    Returns:
        str: By default, this method will simply return the current content decoded content from the &#39;mail&#39;
            attribute. This method is intended to be overwritten by a child class to extend functionality.
    &#34;&#34;&#34;
    return self.mail.content</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mail2beyond.framework.Email"><code class="flex name class">
<span>class <span class="ident">Email</span></span>
<span>(</span><span>server, session, envelope)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an <code><a title="mail2beyond.framework.Email" href="#mail2beyond.framework.Email">Email</a></code> object that contains a decoded SMTP email along with information about the client and server.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>server</code></strong> :&ensp;<code>aiosmtpd.smtp.SMTP</code></dt>
<dd>The <code>SMTP</code> object that handled the email from <code>aiosmtpd</code>.</dd>
<dt><strong><code>session</code></strong> :&ensp;<code>aiosmtpd.smtp.Session</code></dt>
<dd>The <code>Session</code> object that contains client-connection info from <code>aiosmtpd</code>.</dd>
<dt><strong><code>envelope</code></strong> :&ensp;<code>aiosmtpd.smtp.Envelope</code></dt>
<dd>The <code>Envelope</code> object that contains the original email as it was received by
the server from <code>aiosmtpd</code>.</dd>
<dt><strong><code>headers</code></strong> :&ensp;<code>email.message.Message</code></dt>
<dd>The Message object from the 'email' Python module that contains the decoded
SMTP headers.</dd>
</dl>
<p>Initializes the <code><a title="mail2beyond.framework.Email" href="#mail2beyond.framework.Email">Email</a></code> object with required attributes using parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>server</code></strong> :&ensp;<code>aiosmtpd.smtp.SMTP</code></dt>
<dd>The <code>SMTP</code> object that handled the email from <code>aiosmtpd</code>.</dd>
<dt><strong><code>session</code></strong> :&ensp;<code>aiosmtpd.smtp.Session</code></dt>
<dd>The <code>Session</code> object that contains client-connection info from <code>aiosmtpd</code>.</dd>
<dt><strong><code>envelope</code></strong> :&ensp;<code>aiosmtpd.smtp.Envelope</code></dt>
<dd>The <code>Envelope</code> object that contains the original email as it was received
by the server from <code>aiosmtpd</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Email:
    &#34;&#34;&#34;
    Creates an `Email` object that contains a decoded SMTP email along with information about the client and server.

    Attributes:
        server (aiosmtpd.smtp.SMTP): The `SMTP` object that handled the email from `aiosmtpd`.
        session (aiosmtpd.smtp.Session): The `Session` object that contains client-connection info from `aiosmtpd`.
        envelope (aiosmtpd.smtp.Envelope): The `Envelope` object that contains the original email as it was received by
            the server from `aiosmtpd`.
        headers (email.message.Message): The Message object from the &#39;email&#39; Python module that contains the decoded
            SMTP headers.


    &#34;&#34;&#34;

    def __init__(self, server, session, envelope):
        &#34;&#34;&#34;
        Initializes the `Email` object with required attributes using parameters.

        Args:
            server (aiosmtpd.smtp.SMTP): The `SMTP` object that handled the email from `aiosmtpd`.
            session (aiosmtpd.smtp.Session): The `Session` object that contains client-connection info from `aiosmtpd`.
            envelope (aiosmtpd.smtp.Envelope): The `Envelope` object that contains the original email as it was received
                by the server from `aiosmtpd`.
        &#34;&#34;&#34;
        self.server = server
        self.session = session
        self.envelope = envelope
        self.headers = email.message_from_bytes(envelope.content)

    def get_peer_ip(self):
        &#34;&#34;&#34;Gets the IP of the remote peer (client).&#34;&#34;&#34;
        return self.session.peer

    def get_peer_ip_and_port(self):
        &#34;&#34;&#34;Gets the IP and port of the remote peer (client) in IP:PORT format.&#34;&#34;&#34;
        return f&#34;{self.session.peer[0]}:{self.session.peer[1]}&#34;

    def get_server_ip_and_port(self):
        &#34;&#34;&#34;Gets the IP and port of the server that accepted the email in IP:PORT format.&#34;&#34;&#34;
        return f&#34;{self.server.event_handler.address}:{self.server.event_handler.port}&#34;

    # Getters and setters
    @property
    def content(self):
        &#34;&#34;&#34;Gets the decoded content body from the email.&#34;&#34;&#34;
        return self.headers.get_payload(decode=True).decode()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="mail2beyond.framework.Email.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>Gets the decoded content body from the email.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def content(self):
    &#34;&#34;&#34;Gets the decoded content body from the email.&#34;&#34;&#34;
    return self.headers.get_payload(decode=True).decode()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mail2beyond.framework.Email.get_peer_ip"><code class="name flex">
<span>def <span class="ident">get_peer_ip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the IP of the remote peer (client).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_peer_ip(self):
    &#34;&#34;&#34;Gets the IP of the remote peer (client).&#34;&#34;&#34;
    return self.session.peer</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.Email.get_peer_ip_and_port"><code class="name flex">
<span>def <span class="ident">get_peer_ip_and_port</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the IP and port of the remote peer (client) in IP:PORT format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_peer_ip_and_port(self):
    &#34;&#34;&#34;Gets the IP and port of the remote peer (client) in IP:PORT format.&#34;&#34;&#34;
    return f&#34;{self.session.peer[0]}:{self.session.peer[1]}&#34;</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.Email.get_server_ip_and_port"><code class="name flex">
<span>def <span class="ident">get_server_ip_and_port</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the IP and port of the server that accepted the email in IP:PORT format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_server_ip_and_port(self):
    &#34;&#34;&#34;Gets the IP and port of the server that accepted the email in IP:PORT format.&#34;&#34;&#34;
    return f&#34;{self.server.event_handler.address}:{self.server.event_handler.port}&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mail2beyond.framework.Error"><code class="flex name class">
<span>class <span class="ident">Error</span></span>
<span>(</span><span>message:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the <code><a title="mail2beyond.framework.Error" href="#mail2beyond.framework.Error">Error</a></code> object used by mail2beyond.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Error(BaseException):
    &#34;&#34;&#34;Creates the `Error` object used by mail2beyond.&#34;&#34;&#34;
    def __init__(self, message: str):
        super().__init__(message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="mail2beyond.framework.Listener"><code class="flex name class">
<span>class <span class="ident">Listener</span></span>
<span>(</span><span>mappings:list, address:str='127.0.0.1', port:int=62125, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the <code><a title="mail2beyond.framework.Listener" href="#mail2beyond.framework.Listener">Listener</a></code> object that accepts SMTP/SMTPS requests and applies logic based on a specified mappings.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>log</code></strong> :&ensp;<code>logging.Logger</code></dt>
<dd>The Logger object the <code><a title="mail2beyond.framework.Listener" href="#mail2beyond.framework.Listener">Listener</a></code> will use to log events that occur while listening.</dd>
<dt><strong><code>controller</code></strong> :&ensp;<code>aiosmtpd.controller.Controller</code></dt>
<dd>The <code>Controller</code> from <code>aiosmtpd</code> that controls the SMTP server.</dd>
</dl>
<p>Initializes the <code><a title="mail2beyond.framework.Listener" href="#mail2beyond.framework.Listener">Listener</a></code> with the required attributes from arguments.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mappings</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of <code><a title="mail2beyond.framework.Mapping" href="#mail2beyond.framework.Mapping">Mapping</a></code> objects that this listener check whenever an
SMTP message is received. At list one item is required and one item must be a Mapping with its <code>pattern</code>
attribute set to <code>default</code>.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>The local address the <code><a title="mail2beyond.framework.Listener" href="#mail2beyond.framework.Listener">Listener</a></code> will listen for SMTP requests on.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>The local TCP port the <code><a title="mail2beyond.framework.Listener" href="#mail2beyond.framework.Listener">Listener</a></code> will listen for SMTP requests on.</dd>
<dt><strong><code>**tls_context</code></strong> :&ensp;<code>ssl.SSLContext</code></dt>
<dd>The SSLContext object from the 'ssl' library that defines the TLS
configuration for an SMTPS listener. If <code>None</code> is specified, the <code><a title="mail2beyond.framework.Listener" href="#mail2beyond.framework.Listener">Listener</a></code> will not use TLS.</dd>
<dt><strong><code>**enable_starttls</code></strong> :&ensp;<code>bool</code></dt>
<dd>Enables or disables allowing advertisement of the STARTTLS option that allows
clients to automatically upgrade insecure SMTP connections to secure connections. This argument is only
applicable if you have provided a valid <code>tls_context</code>.</dd>
<dt><strong><code>**require_starttls</code></strong> :&ensp;<code>bool</code></dt>
<dd>Enables or disables requiring clients to use the STARTTLS option. If enabled, all
clients must choose the STARTTLS option or the request will be rejected. This argument is only
applicable if you have set <code>enable_starttls</code> to <code>True</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Listener:
    &#34;&#34;&#34;
    Creates the `Listener` object that accepts SMTP/SMTPS requests and applies logic based on a specified mappings.

    Attributes:
        log (logging.Logger): The Logger object the `Listener` will use to log events that occur while listening.
        controller (aiosmtpd.controller.Controller): The `Controller` from `aiosmtpd` that controls the SMTP server.
    &#34;&#34;&#34;
    # Private attributes are not for public consumption.
    # pylint: disable=too-many-instance-attributes

    # Initialize attributes.
    _address = None
    _port = None
    _mappings = None
    _tls_context = None
    _enable_starttls = None
    _require_starttls = None

    def __init__(self, mappings: list, address: str = &#34;127.0.0.1&#34;, port: int = 62125, **kwargs):
        &#34;&#34;&#34;
        Initializes the `Listener` with the required attributes from arguments.

        Args:
            mappings (list): A list of `mail2beyond.framework.Mapping` objects that this listener check whenever an
                SMTP message is received. At list one item is required and one item must be a Mapping with its `pattern`
                attribute set to `default`.
            address (str): The local address the `Listener` will listen for SMTP requests on.
            port (int): The local TCP port the `Listener` will listen for SMTP requests on.
            **tls_context (ssl.SSLContext): The SSLContext object from the &#39;ssl&#39; library that defines the TLS
                configuration for an SMTPS listener. If `None` is specified, the `Listener` will not use TLS.
            **enable_starttls (bool): Enables or disables allowing advertisement of the STARTTLS option that allows
                clients to automatically upgrade insecure SMTP connections to secure connections. This argument is only
                applicable if you have provided a valid `tls_context`.
            **require_starttls (bool): Enables or disables requiring clients to use the STARTTLS option. If enabled, all
                clients must choose the STARTTLS option or the request will be rejected. This argument is only
                applicable if you have set `enable_starttls` to `True`.
        &#34;&#34;&#34;
        # Setup logging
        self.log = None
        self.setup_logging(kwargs.get(&#34;log_level&#34;, logging.NOTSET))

        # Setup mappings and the SMTP controller
        self.controller = None
        self.mappings = mappings
        self.address = address
        self.port = port
        self.tls_context = kwargs.get(&#34;tls_context&#34;, None)
        self.enable_starttls = kwargs.get(&#34;enable_starttls&#34;, False)
        self.require_starttls = kwargs.get(&#34;require_starttls&#34;, False)
        self.setup_controller()

    def start(self):
        &#34;&#34;&#34;
        Starts the `Listener`. This will run the SMTP server in the background. After calling this method, you will
            need to keep the process alive for the SMTP server to continue receiving SMTP connections. You can call the
        `wait()` method to keep the server running indefinitely, or use a function like time.sleep() to keep the
            SMTP server running for a specified amount of time.
        &#34;&#34;&#34;
        self.controller.start()
        self.log.info(f&#34;mail2beyond started listening on {self.address}:{self.port}&#34;)

    @staticmethod
    def wait():
        &#34;&#34;&#34;
        Allows the `Listener` to wait indefinitely, so it can continually accept incoming SMTP messages. This is
        typically called immediately after the `start()` method.
        &#34;&#34;&#34;
        signal.pause()

    def setup_controller(self):
        &#34;&#34;&#34;
        Sets up the `Controller` object with the current address, port and options. If you have made changes to your
        `Listener` object, you will need to call this method to reconfigure the `Controller`.

        Raises:
            mail2beyond.framework.Error: When an unexpected error occurs when creating controllers.
        &#34;&#34;&#34;
        # Setup SMTPS controller if enabled
        if self.tls_context and not self.enable_starttls:
            self.controller = Controller(self, hostname=self.address, port=self.port, ssl_context=self.tls_context)
        # Setup STARTTLS controller if enabled
        elif self.tls_context and self.enable_starttls:
            self.controller = Controller(
                self,
                hostname=self.address,
                port=self.port,
                tls_context=self.tls_context,
                require_starttls=self.require_starttls
            )
        # Setup SMTP controller if no tls_context was provided
        elif not self.tls_context:
            self.controller = Controller(self, hostname=self.address, port=self.port)
        # Throw an error if we somehow ended up here
        else:
            raise Error(&#34;an unexpected error occurred creating the Listener controller&#34;)

    def setup_logging(self, level: int = logging.NOTSET, handler=None, **kwargs):
        &#34;&#34;&#34;
        Sets up the `log` attribute with a configurable Logger for this `Listener`.

        Args:
            level (int): Sets the logging level the Logger will start logging at. See
                https://docs.python.org/3/library/logging.html#logging-levels
            handler (logging.Handler): Sets the logging handler to use. You can pass in a custom Handler like a
                logging.FileHandler to log to a file. If no handler is specified, the default handler
                logging.StreamHandler is assumed which will only print logs to the console.
            **log_format (str): Sets the format of log messages. See
                https://docs.python.org/3/library/logging.html#logging.Formatter.format
            **log_date_format (str): Sets the format of datetime strings in log messages. See
                https://docs.python.org/3/library/logging.html#logging.Formatter.formatTime
        &#34;&#34;&#34;

        # Reset the existing logger
        del self.log

        # Set formatting
        log_format = kwargs.get(&#34;log_format&#34;, &#34;[%(asctime)s][%(levelname)s]:%(message)s&#34;)
        log_date_format = kwargs.get(&#34;log_date_format&#34;, &#34;%b %d %Y %H:%M:%S&#34;)

        # Set handler
        handler = handler if handler else logging.StreamHandler()
        handler.setLevel(level)
        handler.setFormatter(logging.Formatter(fmt=log_format, datefmt=log_date_format))

        # Set the logger
        self.log = logging.getLogger(__name__)
        self.log.setLevel(level)
        self.log.addHandler(handler)

        # Re-assign assigned mappings to re-populate connector loggers
        if self.mappings:
            self.mappings = self.mappings

        # Log debug notice if debug level set
        if level == logging.DEBUG:
            self.log.warning(&#34;logging at level DEBUG may expose sensitive information in logs&#34;)

    def get_default_mapping(self, mappings: (list, None) = None):
        &#34;&#34;&#34;
        Gets the mapping with the `default` pattern from a list of mappings.

        Args:
            mappings (list, None): The list of Mapping objects to search. If none are provided, the mappings defined
                in the `mappings` attribute value will be assumed.

        Raises:
            mail2beyond.framework.Error: When no Mapping object within the list has its `pattern` set to `default`.
        &#34;&#34;&#34;
        # Variables
        mappings = mappings if mappings else self.mappings

        # Loop through each mapping and find the default.
        for mapping in mappings:
            if mapping.pattern == &#34;default&#34;:
                return mapping

        # Return nothing if no default was found.
        raise Error(&#34;mapping with &#39;default&#39; pattern is required&#34;)

    def get_mapping_matches(self, mail: Email):
        &#34;&#34;&#34;
        Gets the mappings that match a specific `Email` object.

        Args:
            mail (mail2beyond.framework.Email): The `Email` object to check for Mapping matches.

        Returns
            list: a list of Mapping objects that matched this `Email`.
        &#34;&#34;&#34;
        # Initialize the default mapping in case there were no direct matches.
        default_mapping = self.get_default_mapping()
        matched_mappings = []

        # Loop through each mapping to check if the condition matches
        for mapping in self.mappings:
            # Only match default as last resort
            if mapping != default_mapping:
                if mapping.is_match(mail.headers.get(mapping.field, None)):
                    matched_mappings.append(mapping)

        # Return the matched mappings if there were any, otherwise return the default mapping.
        if matched_mappings:
            return matched_mappings

        # Otherwise return default mapping
        return [default_mapping]

    async def handle_DATA(self, server, session, envelope):
        &#34;&#34;&#34;
        Overwrites the `handle_DATA()` method from `aiosmtpd` that defines how received SMTP data is handled. There
        shouldn&#39;t be any need for this method to be called explicitly as it is used exclusively by `aiosmtpd`.

        See Also:
            https://aiosmtpd.readthedocs.io/en/latest/handlers.html#handle_DATA

        Args:
            server (aiosmtpd.smtp.SMTP): The `SMTP` object that handled the email from `aiosmtpd`.
            session (aiosmtpd.smtp.Session): The `Session` object that contains client-connection info from `aiosmtpd`.
            envelope (aiosmtpd.smtp.Envelope): The `Envelope` object that contains the original email as it was received
                by the server from `aiosmtpd`.
        &#34;&#34;&#34;
        # Create an email object with the received session and data
        mail = Email(server, session, envelope)

        # Log this connection
        self.log.info(f&#34;server {mail.get_server_ip_and_port()} connection from peer {mail.get_peer_ip_and_port()}&#34;)

        # Pull the mapping that matches this message and send the chat accordingly.
        mappings = self.get_mapping_matches(mail)

        # Loop through each matched mapping and run it&#39;s connector
        for mapping in mappings:
            self.log.debug(
                f&#34;running connector &#39;{mapping.connector}&#39; because {mapping.field.upper()} &#34;
                f&#34;&#39;{mail.headers.get(mapping.field)}&#39; matched mapping &#39;{mapping.pattern}&#39;&#34;
            )

            # Run the connector with this mapping&#39;s parser
            self.log.debug(f&#34;using parser &#39;{mapping.parser}&#39;&#34;)
            mapping.connector.run(mapping.parser(mail))

        return &#39;250 Message accepted&#39;

    # Getters and setters
    @property
    def address(self):
        &#34;&#34;&#34;The property to get and/or set the  address attribute.&#34;&#34;&#34;
        return self._address

    @address.setter
    def address(self, value: str):
        &#34;&#34;&#34;Sets the address attribute after validating the new value.&#34;&#34;&#34;
        # Require address to be valid IP, or localhost
        if value not in [&#34;localhost&#34;]:
            try:
                ipaddress.ip_address(value)
            except ValueError as exc:
                raise Error(&#34;&#39;address&#39; must be valid IP or localhost&#34;) from exc

        self._address = value

    @property
    def port(self):
        &#34;&#34;&#34;The property to get and/or set the  port attribute.&#34;&#34;&#34;
        return self._port

    @port.setter
    def port(self, value: int):
        &#34;&#34;&#34;Sets the port attribute after validating the new value.&#34;&#34;&#34;
        # Require port to be valid TCP port
        if isinstance(value, int) and 1 &lt;= value &lt;= 65535:
            self._port = value
        else:
            raise Error(&#34;&#39;port&#39; must be valid TCP port&#34;)

    @property
    def mappings(self):
        &#34;&#34;&#34;The property to get and/or set the  mappings attribute.&#34;&#34;&#34;
        return self._mappings

    @mappings.setter
    def mappings(self, value: list):
        &#34;&#34;&#34;Sets the mappings attribute after validating the new value.&#34;&#34;&#34;
        # Require mappings to be list
        if not isinstance(value, list):
            raise TypeError(&#34;&#39;mappings&#39; must be type &#39;list&#39;&#34;)

        # Loop through each requested mapping and it is correct object type and a default object is present
        found_default = False
        for mapping in value:
            # Require mapping to be Mapping object
            if not isinstance(mapping, Mapping):
                raise Error(&#34;each &#39;mappings&#39; item must be &#39;Mapping&#39; object&#34;)

            # Check if this mapping is the default.
            if mapping.pattern == &#34;default&#34;:
                # Ensure we have not already found a default
                if not found_default:
                    found_default = True
                else:
                    raise Error(&#34;multiple &#39;mappings&#39; items assigned pattern &#39;default&#39;&#34;)

            # Assign this listener&#39;s logger to each mapping connector
            mapping.connector.log = self.log

        # Ensure we found a default mapping
        if found_default:
            self._mappings = value

        else:
            raise Error(&#34;missing &#39;mappings&#39; item with pattern &#39;default&#39;&#34;)

    @property
    def tls_context(self):
        &#34;&#34;&#34;The property to get and/or set the  tls_context attribute.&#34;&#34;&#34;
        return self._tls_context

    @tls_context.setter
    def tls_context(self, value: ssl.SSLContext):
        &#34;&#34;&#34;Sets the tls_context attribute after validating the new value.&#34;&#34;&#34;
        # Require tls_context to be SSLContext object or None
        if isinstance(value, ssl.SSLContext) or value is None:
            self._tls_context = value
        else:
            raise Error(&#34;&#39;tls_context&#39; must be type &#39;ssl.SSLContext&#39; or &#39;None&#39;&#34;)

    @property
    def enable_starttls(self):
        &#34;&#34;&#34;The property to get and/or set the  enable_starttls attribute.&#34;&#34;&#34;
        return self._enable_starttls

    @enable_starttls.setter
    def enable_starttls(self, value: bool):
        &#34;&#34;&#34;Sets the enable_starttls attribute after validating the new value.&#34;&#34;&#34;
        # Require enable_starttls to be bool
        if isinstance(value, bool):
            self._enable_starttls = value
        else:
            raise Error(&#34;&#39;enable_starttls&#39; must be type &#39;bool&#39;&#34;)

    @property
    def require_starttls(self):
        &#34;&#34;&#34;The property to get and/or set the  require_starttls attribute.&#34;&#34;&#34;
        return self._enable_starttls

    @require_starttls.setter
    def require_starttls(self, value: bool):
        &#34;&#34;&#34;Sets the require_starttls attribute after validating the new value.&#34;&#34;&#34;
        # Require require_starttls to be bool
        if not isinstance(value, bool):
            raise Error(&#34;&#39;require_starttls&#39; must be type &#39;bool&#39;&#34;)

        # Require &#39;enable_tls&#39; to be True before allowing
        if not self.enable_starttls and value:
            raise Error(&#34;&#39;require_starttls&#39; cannot be &#39;True&#39; while &#39;enable_starttls&#39; is &#39;False&#39;&#34;)

        self._require_starttls = value</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="mail2beyond.framework.Listener.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows the <code><a title="mail2beyond.framework.Listener" href="#mail2beyond.framework.Listener">Listener</a></code> to wait indefinitely, so it can continually accept incoming SMTP messages. This is
typically called immediately after the <code>start()</code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def wait():
    &#34;&#34;&#34;
    Allows the `Listener` to wait indefinitely, so it can continually accept incoming SMTP messages. This is
    typically called immediately after the `start()` method.
    &#34;&#34;&#34;
    signal.pause()</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="mail2beyond.framework.Listener.address"><code class="name">var <span class="ident">address</span></code></dt>
<dd>
<div class="desc"><p>The property to get and/or set the
address attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self):
    &#34;&#34;&#34;The property to get and/or set the  address attribute.&#34;&#34;&#34;
    return self._address</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.Listener.enable_starttls"><code class="name">var <span class="ident">enable_starttls</span></code></dt>
<dd>
<div class="desc"><p>The property to get and/or set the
enable_starttls attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def enable_starttls(self):
    &#34;&#34;&#34;The property to get and/or set the  enable_starttls attribute.&#34;&#34;&#34;
    return self._enable_starttls</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.Listener.mappings"><code class="name">var <span class="ident">mappings</span></code></dt>
<dd>
<div class="desc"><p>The property to get and/or set the
mappings attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mappings(self):
    &#34;&#34;&#34;The property to get and/or set the  mappings attribute.&#34;&#34;&#34;
    return self._mappings</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.Listener.port"><code class="name">var <span class="ident">port</span></code></dt>
<dd>
<div class="desc"><p>The property to get and/or set the
port attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def port(self):
    &#34;&#34;&#34;The property to get and/or set the  port attribute.&#34;&#34;&#34;
    return self._port</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.Listener.require_starttls"><code class="name">var <span class="ident">require_starttls</span></code></dt>
<dd>
<div class="desc"><p>The property to get and/or set the
require_starttls attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def require_starttls(self):
    &#34;&#34;&#34;The property to get and/or set the  require_starttls attribute.&#34;&#34;&#34;
    return self._enable_starttls</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.Listener.tls_context"><code class="name">var <span class="ident">tls_context</span></code></dt>
<dd>
<div class="desc"><p>The property to get and/or set the
tls_context attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tls_context(self):
    &#34;&#34;&#34;The property to get and/or set the  tls_context attribute.&#34;&#34;&#34;
    return self._tls_context</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mail2beyond.framework.Listener.get_default_mapping"><code class="name flex">
<span>def <span class="ident">get_default_mapping</span></span>(<span>self, mappings:(<class'list'>,None)=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the mapping with the <code>default</code> pattern from a list of mappings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mappings</code></strong> :&ensp;<code>list, None</code></dt>
<dd>The list of Mapping objects to search. If none are provided, the mappings defined
in the <code>mappings</code> attribute value will be assumed.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="mail2beyond.framework.Error" href="#mail2beyond.framework.Error">Error</a></code></dt>
<dd>When no Mapping object within the list has its <code>pattern</code> set to <code>default</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_default_mapping(self, mappings: (list, None) = None):
    &#34;&#34;&#34;
    Gets the mapping with the `default` pattern from a list of mappings.

    Args:
        mappings (list, None): The list of Mapping objects to search. If none are provided, the mappings defined
            in the `mappings` attribute value will be assumed.

    Raises:
        mail2beyond.framework.Error: When no Mapping object within the list has its `pattern` set to `default`.
    &#34;&#34;&#34;
    # Variables
    mappings = mappings if mappings else self.mappings

    # Loop through each mapping and find the default.
    for mapping in mappings:
        if mapping.pattern == &#34;default&#34;:
            return mapping

    # Return nothing if no default was found.
    raise Error(&#34;mapping with &#39;default&#39; pattern is required&#34;)</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.Listener.get_mapping_matches"><code class="name flex">
<span>def <span class="ident">get_mapping_matches</span></span>(<span>self, mail:<a title="mail2beyond.framework.Email" href="#mail2beyond.framework.Email">Email</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the mappings that match a specific <code><a title="mail2beyond.framework.Email" href="#mail2beyond.framework.Email">Email</a></code> object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mail</code></strong> :&ensp;<code><a title="mail2beyond.framework.Email" href="#mail2beyond.framework.Email">Email</a></code></dt>
<dd>The <code><a title="mail2beyond.framework.Email" href="#mail2beyond.framework.Email">Email</a></code> object to check for Mapping matches.</dd>
</dl>
<p>Returns
list: a list of Mapping objects that matched this <code><a title="mail2beyond.framework.Email" href="#mail2beyond.framework.Email">Email</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mapping_matches(self, mail: Email):
    &#34;&#34;&#34;
    Gets the mappings that match a specific `Email` object.

    Args:
        mail (mail2beyond.framework.Email): The `Email` object to check for Mapping matches.

    Returns
        list: a list of Mapping objects that matched this `Email`.
    &#34;&#34;&#34;
    # Initialize the default mapping in case there were no direct matches.
    default_mapping = self.get_default_mapping()
    matched_mappings = []

    # Loop through each mapping to check if the condition matches
    for mapping in self.mappings:
        # Only match default as last resort
        if mapping != default_mapping:
            if mapping.is_match(mail.headers.get(mapping.field, None)):
                matched_mappings.append(mapping)

    # Return the matched mappings if there were any, otherwise return the default mapping.
    if matched_mappings:
        return matched_mappings

    # Otherwise return default mapping
    return [default_mapping]</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.Listener.handle_DATA"><code class="name flex">
<span>async def <span class="ident">handle_DATA</span></span>(<span>self, server, session, envelope)</span>
</code></dt>
<dd>
<div class="desc"><p>Overwrites the <code>handle_DATA()</code> method from <code>aiosmtpd</code> that defines how received SMTP data is handled. There
shouldn't be any need for this method to be called explicitly as it is used exclusively by <code>aiosmtpd</code>.</p>
<p>See Also:
<a href="https://aiosmtpd.readthedocs.io/en/latest/handlers.html#handle_DATA">https://aiosmtpd.readthedocs.io/en/latest/handlers.html#handle_DATA</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>server</code></strong> :&ensp;<code>aiosmtpd.smtp.SMTP</code></dt>
<dd>The <code>SMTP</code> object that handled the email from <code>aiosmtpd</code>.</dd>
<dt><strong><code>session</code></strong> :&ensp;<code>aiosmtpd.smtp.Session</code></dt>
<dd>The <code>Session</code> object that contains client-connection info from <code>aiosmtpd</code>.</dd>
<dt><strong><code>envelope</code></strong> :&ensp;<code>aiosmtpd.smtp.Envelope</code></dt>
<dd>The <code>Envelope</code> object that contains the original email as it was received
by the server from <code>aiosmtpd</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_DATA(self, server, session, envelope):
    &#34;&#34;&#34;
    Overwrites the `handle_DATA()` method from `aiosmtpd` that defines how received SMTP data is handled. There
    shouldn&#39;t be any need for this method to be called explicitly as it is used exclusively by `aiosmtpd`.

    See Also:
        https://aiosmtpd.readthedocs.io/en/latest/handlers.html#handle_DATA

    Args:
        server (aiosmtpd.smtp.SMTP): The `SMTP` object that handled the email from `aiosmtpd`.
        session (aiosmtpd.smtp.Session): The `Session` object that contains client-connection info from `aiosmtpd`.
        envelope (aiosmtpd.smtp.Envelope): The `Envelope` object that contains the original email as it was received
            by the server from `aiosmtpd`.
    &#34;&#34;&#34;
    # Create an email object with the received session and data
    mail = Email(server, session, envelope)

    # Log this connection
    self.log.info(f&#34;server {mail.get_server_ip_and_port()} connection from peer {mail.get_peer_ip_and_port()}&#34;)

    # Pull the mapping that matches this message and send the chat accordingly.
    mappings = self.get_mapping_matches(mail)

    # Loop through each matched mapping and run it&#39;s connector
    for mapping in mappings:
        self.log.debug(
            f&#34;running connector &#39;{mapping.connector}&#39; because {mapping.field.upper()} &#34;
            f&#34;&#39;{mail.headers.get(mapping.field)}&#39; matched mapping &#39;{mapping.pattern}&#39;&#34;
        )

        # Run the connector with this mapping&#39;s parser
        self.log.debug(f&#34;using parser &#39;{mapping.parser}&#39;&#34;)
        mapping.connector.run(mapping.parser(mail))

    return &#39;250 Message accepted&#39;</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.Listener.setup_controller"><code class="name flex">
<span>def <span class="ident">setup_controller</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up the <code>Controller</code> object with the current address, port and options. If you have made changes to your
<code><a title="mail2beyond.framework.Listener" href="#mail2beyond.framework.Listener">Listener</a></code> object, you will need to call this method to reconfigure the <code>Controller</code>.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="mail2beyond.framework.Error" href="#mail2beyond.framework.Error">Error</a></code></dt>
<dd>When an unexpected error occurs when creating controllers.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_controller(self):
    &#34;&#34;&#34;
    Sets up the `Controller` object with the current address, port and options. If you have made changes to your
    `Listener` object, you will need to call this method to reconfigure the `Controller`.

    Raises:
        mail2beyond.framework.Error: When an unexpected error occurs when creating controllers.
    &#34;&#34;&#34;
    # Setup SMTPS controller if enabled
    if self.tls_context and not self.enable_starttls:
        self.controller = Controller(self, hostname=self.address, port=self.port, ssl_context=self.tls_context)
    # Setup STARTTLS controller if enabled
    elif self.tls_context and self.enable_starttls:
        self.controller = Controller(
            self,
            hostname=self.address,
            port=self.port,
            tls_context=self.tls_context,
            require_starttls=self.require_starttls
        )
    # Setup SMTP controller if no tls_context was provided
    elif not self.tls_context:
        self.controller = Controller(self, hostname=self.address, port=self.port)
    # Throw an error if we somehow ended up here
    else:
        raise Error(&#34;an unexpected error occurred creating the Listener controller&#34;)</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.Listener.setup_logging"><code class="name flex">
<span>def <span class="ident">setup_logging</span></span>(<span>self, level:int=0, handler=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up the <code>log</code> attribute with a configurable Logger for this <code><a title="mail2beyond.framework.Listener" href="#mail2beyond.framework.Listener">Listener</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>Sets the logging level the Logger will start logging at. See
<a href="https://docs.python.org/3/library/logging.html#logging-levels">https://docs.python.org/3/library/logging.html#logging-levels</a></dd>
<dt><strong><code>handler</code></strong> :&ensp;<code>logging.Handler</code></dt>
<dd>Sets the logging handler to use. You can pass in a custom Handler like a
logging.FileHandler to log to a file. If no handler is specified, the default handler
logging.StreamHandler is assumed which will only print logs to the console.</dd>
<dt><strong><code>**log_format</code></strong> :&ensp;<code>str</code></dt>
<dd>Sets the format of log messages. See
<a href="https://docs.python.org/3/library/logging.html#logging.Formatter.format">https://docs.python.org/3/library/logging.html#logging.Formatter.format</a></dd>
<dt><strong><code>**log_date_format</code></strong> :&ensp;<code>str</code></dt>
<dd>Sets the format of datetime strings in log messages. See
<a href="https://docs.python.org/3/library/logging.html#logging.Formatter.formatTime">https://docs.python.org/3/library/logging.html#logging.Formatter.formatTime</a></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_logging(self, level: int = logging.NOTSET, handler=None, **kwargs):
    &#34;&#34;&#34;
    Sets up the `log` attribute with a configurable Logger for this `Listener`.

    Args:
        level (int): Sets the logging level the Logger will start logging at. See
            https://docs.python.org/3/library/logging.html#logging-levels
        handler (logging.Handler): Sets the logging handler to use. You can pass in a custom Handler like a
            logging.FileHandler to log to a file. If no handler is specified, the default handler
            logging.StreamHandler is assumed which will only print logs to the console.
        **log_format (str): Sets the format of log messages. See
            https://docs.python.org/3/library/logging.html#logging.Formatter.format
        **log_date_format (str): Sets the format of datetime strings in log messages. See
            https://docs.python.org/3/library/logging.html#logging.Formatter.formatTime
    &#34;&#34;&#34;

    # Reset the existing logger
    del self.log

    # Set formatting
    log_format = kwargs.get(&#34;log_format&#34;, &#34;[%(asctime)s][%(levelname)s]:%(message)s&#34;)
    log_date_format = kwargs.get(&#34;log_date_format&#34;, &#34;%b %d %Y %H:%M:%S&#34;)

    # Set handler
    handler = handler if handler else logging.StreamHandler()
    handler.setLevel(level)
    handler.setFormatter(logging.Formatter(fmt=log_format, datefmt=log_date_format))

    # Set the logger
    self.log = logging.getLogger(__name__)
    self.log.setLevel(level)
    self.log.addHandler(handler)

    # Re-assign assigned mappings to re-populate connector loggers
    if self.mappings:
        self.mappings = self.mappings

    # Log debug notice if debug level set
    if level == logging.DEBUG:
        self.log.warning(&#34;logging at level DEBUG may expose sensitive information in logs&#34;)</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.Listener.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts the <code><a title="mail2beyond.framework.Listener" href="#mail2beyond.framework.Listener">Listener</a></code>. This will run the SMTP server in the background. After calling this method, you will
need to keep the process alive for the SMTP server to continue receiving SMTP connections. You can call the
<code>wait()</code> method to keep the server running indefinitely, or use a function like time.sleep() to keep the
SMTP server running for a specified amount of time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;
    Starts the `Listener`. This will run the SMTP server in the background. After calling this method, you will
        need to keep the process alive for the SMTP server to continue receiving SMTP connections. You can call the
    `wait()` method to keep the server running indefinitely, or use a function like time.sleep() to keep the
        SMTP server running for a specified amount of time.
    &#34;&#34;&#34;
    self.controller.start()
    self.log.info(f&#34;mail2beyond started listening on {self.address}:{self.port}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mail2beyond.framework.Mapping"><code class="flex name class">
<span>class <span class="ident">Mapping</span></span>
<span>(</span><span>pattern:str, connector, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Mapping object that defines parameters to control the formatting and redirection of received SMTP
messages. Whenever an SMTP message is received, Mappings are checked by the <code><a title="mail2beyond.framework.Listener" href="#mail2beyond.framework.Listener">Listener</a></code> to see if the received SMTP
message headers match the regex defined in the Mapping object.</p>
<p>Initializes the Mapping object with desired attributes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pattern</code></strong> :&ensp;<code>str</code></dt>
<dd>The regex pattern to use when checking SMTP headers for specific values.</dd>
<dt><strong><code>connector</code></strong> :&ensp;<code><a title="mail2beyond.framework.BaseConnector" href="#mail2beyond.framework.BaseConnector">BaseConnector</a></code></dt>
<dd>The Connector object this Mapping will use whenever a
match is found. This must be an object of a class that has a base class of
<code><a title="mail2beyond.framework.BaseConnector" href="#mail2beyond.framework.BaseConnector">BaseConnector</a></code>. You should pass in a built-in <code>Connector</code> object created from the
mail2beyond.connectors module or your own custom <code>Connector</code> object.</dd>
<dt>**field (str) The SMTP header to run the regex pattern against. This is commonly the TO or FROM headers to</dt>
<dt>check the email's recipient or sender respectively, but can be any header available in the received</dt>
<dt>email. Defaults to <code>from</code>.</dt>
<dt><strong><code>**parser</code></strong> :&ensp;<code><a title="mail2beyond.framework.BaseParser" href="#mail2beyond.framework.BaseParser">BaseParser</a></code></dt>
<dd>The Parser class to use whenever this Mapping is matched. This
allows you to specify a Parser class that will parse the email's content body to a more human-readable
format. Note this must be the Parser class NOT a <code>Parser</code> object. This must be Parser class with a base
class of <code><a title="mail2beyond.framework.BaseParser" href="#mail2beyond.framework.BaseParser">BaseParser</a></code>. Defaults to the <code><a title="mail2beyond.framework.BaseParser" href="#mail2beyond.framework.BaseParser">BaseParser</a></code> class,
but it is strongly recommended you pass in <code><a title="mail2beyond.parsers.auto.Parser" href="parsers/auto.html#mail2beyond.parsers.auto.Parser">Parser</a></code> to automatically parse
the content body based on the email's content-type header or pass in your own custom parser class.</dd>
</dl>
<p>See Also:
<a href="https://github.com/jaredhendrickson13/mail2beyond/blob/master/docs/PACKAGE.md#writing-custom-connectors">https://github.com/jaredhendrickson13/mail2beyond/blob/master/docs/PACKAGE.md#writing-custom-connectors</a>
<a href="https://github.com/jaredhendrickson13/mail2beyond/blob/master/docs/PACKAGE.md#writing-custom-parsers">https://github.com/jaredhendrickson13/mail2beyond/blob/master/docs/PACKAGE.md#writing-custom-parsers</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mapping:
    &#34;&#34;&#34;
    Creates a Mapping object that defines parameters to control the formatting and redirection of received SMTP
    messages. Whenever an SMTP message is received, Mappings are checked by the `Listener` to see if the received SMTP
    message headers match the regex defined in the Mapping object.
    &#34;&#34;&#34;
    # Private attributes are not for public consumption.
    # pylint: disable=too-many-instance-attributes

    # Initialize attributes
    _pattern = None
    _field = None
    _connector = None
    _parser = None

    def __init__(self, pattern: str, connector, **kwargs):
        &#34;&#34;&#34;
        Initializes the Mapping object with desired attributes.

        Args:
            pattern (str): The regex pattern to use when checking SMTP headers for specific values.
            connector (mail2beyond.framework.BaseConnector): The Connector object this Mapping will use whenever a
                match is found. This must be an object of a class that has a base class of
                `mail2beyond.framework.BaseConnector`. You should pass in a built-in `Connector` object created from the
                mail2beyond.connectors module or your own custom `Connector` object.
            **field (str) The SMTP header to run the regex pattern against. This is commonly the TO or FROM headers to
                check the email&#39;s recipient or sender respectively, but can be any header available in the received
                email. Defaults to `from`.
            **parser (mail2beyond.framework.BaseParser): The Parser class to use whenever this Mapping is matched. This
                allows you to specify a Parser class that will parse the email&#39;s content body to a more human-readable
                format. Note this must be the Parser class NOT a `Parser` object. This must be Parser class with a base
                class of `mail2beyond.framework.BaseParser`. Defaults to the `mail2beyond.framework.BaseParser` class,
                but it is strongly recommended you pass in `mail2beyond.parsers.auto.Parser` to automatically parse
                the content body based on the email&#39;s content-type header or pass in your own custom parser class.

        See Also:
            https://github.com/jaredhendrickson13/mail2beyond/blob/master/docs/PACKAGE.md#writing-custom-connectors
            https://github.com/jaredhendrickson13/mail2beyond/blob/master/docs/PACKAGE.md#writing-custom-parsers
        &#34;&#34;&#34;
        # Assign required attributes
        self.pattern = pattern
        self.connector = connector

        # Assign optional attributes, or assume defaults.
        self.field = kwargs.get(&#34;field&#34;, &#34;from&#34;)
        self.parser = kwargs.get(&#34;parser&#34;, BaseParser)

    def __str__(self):
        &#34;&#34;&#34;Sets the object&#39;s pattern as the string representation of this object.&#34;&#34;&#34;
        return self.pattern

    def is_match(self, value):
        &#34;&#34;&#34;
        Checks if a specified value matches this mapping.

        Args:
            value (str): The value to check for a regex pattern match.

        Returns:
            bool: Whether the value was a match for the regex pattern or not.
        &#34;&#34;&#34;
        # Check if the value matches this mapping&#39;s regex pattern.
        if value is not None and re.search(self.pattern, value):
            return True
        # No match, return False
        return False

    # Getters and setters #
    @property
    def pattern(self):
        &#34;&#34;&#34;The property to get and/or set the  pattern attribute.&#34;&#34;&#34;
        return self._pattern

    @pattern.setter
    def pattern(self, value: str):
        &#34;&#34;&#34;Sets the pattern attribute after validating the new value.&#34;&#34;&#34;
        # Require pattern to be a string
        if isinstance(value, str):
            self._pattern = value
        else:
            raise TypeError(&#34;pattern must be type &#39;str&#39;&#34;)

    @property
    def connector(self):
        &#34;&#34;&#34;The property to get and/or set the  connector attribute.&#34;&#34;&#34;
        return self._connector

    @connector.setter
    def connector(self, value):
        &#34;&#34;&#34;Sets the connector attribute after validating the new value.&#34;&#34;&#34;
        # Require connector to have a base class of mail2beyond.framework.BaseConnector
        if value.__class__.__base__ == BaseConnector:
            self._connector = value
        else:
            raise TypeError(&#34;connector must be object with base class &#39;BaseConnector&#39;&#34;)

    @property
    def parser(self):
        &#34;&#34;&#34;The property to get and/or set the  parser attribute.&#34;&#34;&#34;
        return self._parser

    @parser.setter
    def parser(self, value):
        &#34;&#34;&#34;Sets the parser attribute after validating the new value.&#34;&#34;&#34;
        # Require parser to have a base class of mail2beyond.framework.BaseParser
        if inspect.isclass(value) and hasattr(value, &#34;parse_content&#34;):
            self._parser = value
        else:
            raise TypeError(&#34;parser must be a class (not object) with base class &#39;BaseParser&#39;&#34;)

    @property
    def field(self):
        &#34;&#34;&#34;The property to get and/or set the  field attribute.&#34;&#34;&#34;
        return self._field

    @field.setter
    def field(self, value: str):
        &#34;&#34;&#34;Sets the field attribute after validating the new value.&#34;&#34;&#34;
        # Require field to be a support/recognized field
        if isinstance(value, str):
            self._field = value
        else:
            raise ValueError(&#34;field must be type &#39;str&#39;&#34;)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="mail2beyond.framework.Mapping.connector"><code class="name">var <span class="ident">connector</span></code></dt>
<dd>
<div class="desc"><p>The property to get and/or set the
connector attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connector(self):
    &#34;&#34;&#34;The property to get and/or set the  connector attribute.&#34;&#34;&#34;
    return self._connector</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.Mapping.field"><code class="name">var <span class="ident">field</span></code></dt>
<dd>
<div class="desc"><p>The property to get and/or set the
field attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def field(self):
    &#34;&#34;&#34;The property to get and/or set the  field attribute.&#34;&#34;&#34;
    return self._field</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.Mapping.parser"><code class="name">var <span class="ident">parser</span></code></dt>
<dd>
<div class="desc"><p>The property to get and/or set the
parser attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parser(self):
    &#34;&#34;&#34;The property to get and/or set the  parser attribute.&#34;&#34;&#34;
    return self._parser</code></pre>
</details>
</dd>
<dt id="mail2beyond.framework.Mapping.pattern"><code class="name">var <span class="ident">pattern</span></code></dt>
<dd>
<div class="desc"><p>The property to get and/or set the
pattern attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pattern(self):
    &#34;&#34;&#34;The property to get and/or set the  pattern attribute.&#34;&#34;&#34;
    return self._pattern</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mail2beyond.framework.Mapping.is_match"><code class="name flex">
<span>def <span class="ident">is_match</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a specified value matches this mapping.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>The value to check for a regex pattern match.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the value was a match for the regex pattern or not.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_match(self, value):
    &#34;&#34;&#34;
    Checks if a specified value matches this mapping.

    Args:
        value (str): The value to check for a regex pattern match.

    Returns:
        bool: Whether the value was a match for the regex pattern or not.
    &#34;&#34;&#34;
    # Check if the value matches this mapping&#39;s regex pattern.
    if value is not None and re.search(self.pattern, value):
        return True
    # No match, return False
    return False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mail2beyond" href="index.html">mail2beyond</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mail2beyond.framework.BaseConnector" href="#mail2beyond.framework.BaseConnector">BaseConnector</a></code></h4>
<ul class="">
<li><code><a title="mail2beyond.framework.BaseConnector.name" href="#mail2beyond.framework.BaseConnector.name">name</a></code></li>
<li><code><a title="mail2beyond.framework.BaseConnector.pre_submit" href="#mail2beyond.framework.BaseConnector.pre_submit">pre_submit</a></code></li>
<li><code><a title="mail2beyond.framework.BaseConnector.run" href="#mail2beyond.framework.BaseConnector.run">run</a></code></li>
<li><code><a title="mail2beyond.framework.BaseConnector.submit" href="#mail2beyond.framework.BaseConnector.submit">submit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mail2beyond.framework.BaseParser" href="#mail2beyond.framework.BaseParser">BaseParser</a></code></h4>
<ul class="two-column">
<li><code><a title="mail2beyond.framework.BaseParser.config" href="#mail2beyond.framework.BaseParser.config">config</a></code></li>
<li><code><a title="mail2beyond.framework.BaseParser.content" href="#mail2beyond.framework.BaseParser.content">content</a></code></li>
<li><code><a title="mail2beyond.framework.BaseParser.mail" href="#mail2beyond.framework.BaseParser.mail">mail</a></code></li>
<li><code><a title="mail2beyond.framework.BaseParser.name" href="#mail2beyond.framework.BaseParser.name">name</a></code></li>
<li><code><a title="mail2beyond.framework.BaseParser.parse_content" href="#mail2beyond.framework.BaseParser.parse_content">parse_content</a></code></li>
<li><code><a title="mail2beyond.framework.BaseParser.subject" href="#mail2beyond.framework.BaseParser.subject">subject</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mail2beyond.framework.Email" href="#mail2beyond.framework.Email">Email</a></code></h4>
<ul class="">
<li><code><a title="mail2beyond.framework.Email.content" href="#mail2beyond.framework.Email.content">content</a></code></li>
<li><code><a title="mail2beyond.framework.Email.get_peer_ip" href="#mail2beyond.framework.Email.get_peer_ip">get_peer_ip</a></code></li>
<li><code><a title="mail2beyond.framework.Email.get_peer_ip_and_port" href="#mail2beyond.framework.Email.get_peer_ip_and_port">get_peer_ip_and_port</a></code></li>
<li><code><a title="mail2beyond.framework.Email.get_server_ip_and_port" href="#mail2beyond.framework.Email.get_server_ip_and_port">get_server_ip_and_port</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mail2beyond.framework.Error" href="#mail2beyond.framework.Error">Error</a></code></h4>
</li>
<li>
<h4><code><a title="mail2beyond.framework.Listener" href="#mail2beyond.framework.Listener">Listener</a></code></h4>
<ul class="two-column">
<li><code><a title="mail2beyond.framework.Listener.address" href="#mail2beyond.framework.Listener.address">address</a></code></li>
<li><code><a title="mail2beyond.framework.Listener.enable_starttls" href="#mail2beyond.framework.Listener.enable_starttls">enable_starttls</a></code></li>
<li><code><a title="mail2beyond.framework.Listener.get_default_mapping" href="#mail2beyond.framework.Listener.get_default_mapping">get_default_mapping</a></code></li>
<li><code><a title="mail2beyond.framework.Listener.get_mapping_matches" href="#mail2beyond.framework.Listener.get_mapping_matches">get_mapping_matches</a></code></li>
<li><code><a title="mail2beyond.framework.Listener.handle_DATA" href="#mail2beyond.framework.Listener.handle_DATA">handle_DATA</a></code></li>
<li><code><a title="mail2beyond.framework.Listener.mappings" href="#mail2beyond.framework.Listener.mappings">mappings</a></code></li>
<li><code><a title="mail2beyond.framework.Listener.port" href="#mail2beyond.framework.Listener.port">port</a></code></li>
<li><code><a title="mail2beyond.framework.Listener.require_starttls" href="#mail2beyond.framework.Listener.require_starttls">require_starttls</a></code></li>
<li><code><a title="mail2beyond.framework.Listener.setup_controller" href="#mail2beyond.framework.Listener.setup_controller">setup_controller</a></code></li>
<li><code><a title="mail2beyond.framework.Listener.setup_logging" href="#mail2beyond.framework.Listener.setup_logging">setup_logging</a></code></li>
<li><code><a title="mail2beyond.framework.Listener.start" href="#mail2beyond.framework.Listener.start">start</a></code></li>
<li><code><a title="mail2beyond.framework.Listener.tls_context" href="#mail2beyond.framework.Listener.tls_context">tls_context</a></code></li>
<li><code><a title="mail2beyond.framework.Listener.wait" href="#mail2beyond.framework.Listener.wait">wait</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mail2beyond.framework.Mapping" href="#mail2beyond.framework.Mapping">Mapping</a></code></h4>
<ul class="">
<li><code><a title="mail2beyond.framework.Mapping.connector" href="#mail2beyond.framework.Mapping.connector">connector</a></code></li>
<li><code><a title="mail2beyond.framework.Mapping.field" href="#mail2beyond.framework.Mapping.field">field</a></code></li>
<li><code><a title="mail2beyond.framework.Mapping.is_match" href="#mail2beyond.framework.Mapping.is_match">is_match</a></code></li>
<li><code><a title="mail2beyond.framework.Mapping.parser" href="#mail2beyond.framework.Mapping.parser">parser</a></code></li>
<li><code><a title="mail2beyond.framework.Mapping.pattern" href="#mail2beyond.framework.Mapping.pattern">pattern</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>